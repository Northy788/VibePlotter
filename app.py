import streamlit as st
import pandas as pd
import plotly.graph_objs as go
import re
import expression  # import expression.py
from datetime import datetime, timedelta
from multiprocessing import Pool, cpu_count
import io
import numexpr as ne

st.set_page_config(page_title="VibePlotter", layout="wide")
st.title("üìä VibePlotter")

def parse_simple_excel_formula(s):
    if not isinstance(s, str):
        return s
    if not s.startswith('='):
        return s

    pattern_time = r'=TEXT\((\d+)(?:\/86400\s*\+\s*25569)\s*,\s*"([^"]+)"\)\s*&\s*"\."\s*&(\d+)'
    m_time = re.match(pattern_time, s)
    if m_time:
        unix_ts = int(m_time.group(1))
        fmt = m_time.group(2)
        suffix = m_time.group(3)
        dt = datetime.utcfromtimestamp(unix_ts)
        fmt = fmt.replace("ddd", "%a").replace("dd", "%d").replace("mmm", "%b").replace("yyyy", "%Y").replace("hh", "%H").replace("mm", "%M").replace("ss", "%S")
        formatted_dt = dt.strftime(fmt)
        return f"{formatted_dt}.{suffix}"

    pattern_concat = r'=(\d+)&"\."&TEXT\((\d+),"0+"\)'
    m = re.match(pattern_concat, s)
    if m:
        num1 = m.group(1)
        num2 = m.group(2)
        zero_format = re.search(r'"(0+)"', s)
        width = len(zero_format.group(1)) if zero_format else len(num2)
        num2_formatted = num2.zfill(width)
        return f"{num1}.{num2_formatted}"
    return s

def process_file(file):
    file_content = file.getvalue()
    df = pd.read_csv(io.BytesIO(file_content), encoding='utf-8-sig')
    df = df.applymap(parse_simple_excel_formula)
    name = file.name
    return name, df, set(df.columns)


uploaded_files = st.file_uploader("üìÇ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå CSV", type="csv", accept_multiple_files=True)

if uploaded_files:
    with st.spinner("üîÑ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå..."):
        with Pool(processes=cpu_count()) as pool:
            results = pool.map(process_file, uploaded_files)

        dataframes = {name: df for name, df, _ in results}
        column_sets = [cols for _, _, cols in results]

        common_columns = sorted(set.intersection(*column_sets)) if column_sets else []

    if not common_columns:
        st.warning("‚ùó ‡πÑ‡∏°‡πà‡∏°‡∏µ column ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ô‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏Å‡∏ô X")
    else:
        st.markdown("### üî¢ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏Å‡∏ô X (‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡πÑ‡∏ü‡∏•‡πå) - ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏î‡πâ‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 1 ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå")
        x_cols = st.multiselect("‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏Å‡∏ô X", common_columns, default=[common_columns[0]])

        fig = go.Figure()

        for name, df in dataframes.items():
            st.markdown(f"### üìÑ ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå: `{name}`")
            
            # <<< ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏î‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏•‡∏∞‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏ñ‡∏π‡∏Å‡∏•‡∏ö‡∏≠‡∏≠‡∏Å‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß
            
            y_cols = st.multiselect(f"‚úÖ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå Y ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á (‡πÑ‡∏ü‡∏•‡πå: {name})", list(df.columns), key=f"ycol_{name}")

            for col in y_cols:
                with st.expander(f"‚öôÔ∏è ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö `{col}`", expanded=False):
                    cols = st.columns([3, 3, 1, 2, 2])
                    with cols[0]:
                        preset = st.selectbox("üõ†Ô∏è ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Expression ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏£‡∏π‡∏õ", list(expression.expressions.keys()), key=f"preset_{name}_{col}")
                    with cols[1]:
                        expr_text = st.text_input(f"‚úèÔ∏è ‡∏´‡∏£‡∏∑‡∏≠ ‡∏Å‡∏£‡∏≠‡∏Å Expression ‡πÄ‡∏≠‡∏á (‡πÉ‡∏ä‡πâ 'x' ‡πÅ‡∏ó‡∏ô‡∏Ñ‡πà‡∏≤‡∏î‡∏¥‡∏ö)", value="x", key=f"expr_{name}_{col}")
                    with cols[2]:
                        scatter = st.checkbox("üîò ‡∏à‡∏∏‡∏î scatter", value=True, key=f"scatter_{name}_{col}")
                    with cols[3]:
                        color = st.color_picker("üé® ‡∏™‡∏µ‡πÄ‡∏™‡πâ‡∏ô", value="#0000FF", key=f"color_{name}_{col}")
                    with cols[4]:
                        display_name = st.text_input("üìù ‡∏ä‡∏∑‡πà‡∏≠‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏î‡∏á‡∏ö‡∏ô‡∏Å‡∏£‡∏≤‡∏ü", value=f"{name}:{col}", key=f"name_{name}_{col}")

                for x_col in x_cols:
                    if x_col not in df.columns or col not in df.columns:
                        st.error(f"‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå `{x_col}` ‡∏´‡∏£‡∏∑‡∏≠ `{col}` ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå `{name}`")
                        continue
                    try:
                        x_data = df[x_col]
                        y_raw = df[col]

                        if preset != "None":
                            expr_func = expression.expressions[preset]
                            y_data = expr_func(y_raw)
                        else:
                            local_dict = {'x': y_raw, 'np': __import__("numpy")}
                            y_data = ne.evaluate(expr_text, local_dict=local_dict)

                    except Exception as e:
                        st.error(f"‚ùå Expression ‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô `{col}`: {e}")
                        continue

                    trace_name = f"{display_name} (X: {x_col})"
                    fig.add_trace(go.Scattergl(
                        x=x_data,
                        y=y_data,
                        mode="lines+markers" if scatter else "lines",
                        name=trace_name,
                        line=dict(color=color),
                        marker=dict(size=6) if scatter else None,
                        hovertemplate="<b>X:</b> %{x:.6f}<br><b>Y:</b> %{y:.6f}<extra></extra>"
                    ))

        fig.update_layout(
            title="üìà ‡∏Å‡∏£‡∏≤‡∏ü‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå CSV",
            xaxis_title="‡πÅ‡∏Å‡∏ô X ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å",
            yaxis_title="‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•",
            height=700,
            legend=dict(
                orientation="h",
                yanchor="bottom",
                y=-0.3,
                xanchor="center",
                x=0.5
            )
        )
        st.plotly_chart(fig, use_container_width=True)